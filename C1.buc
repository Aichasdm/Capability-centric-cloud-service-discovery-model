<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.contextFile org.eventb.core.configuration="org.eventb.core.fwd;de.prob.symbolic.ctxBase" org.eventb.core.generated="false" org.eventb.texttools.text_lastmodified="1741703284216" org.eventb.texttools.text_representation="context C1 extends C0&#10;&#10;constants&#10;SpecificationRelation // relation between twos elements of MGV e.g in locations locatedIn is a SpecificationRelation between two locations Sydney and Australia&#10;SpecificationRelationOnSets // relation between twos sets of MGV e.g in locations locatedIn is a SpecificationRelation between to locations {Melbourne,Sydney} and {Australia}&#10;&#10;//this context is used to define specification relation between capability&#10;axioms&#10;  @AXM_SR SpecificationRelation ∈ ℙ(GENERALVALUES) ⇸ ℙ(GENERALVALUES × GENERALVALUES) // SpecificationRelation is a partial relation on an MGV mgv .I v1 and v2 are twos values of mgv and v1↦v2 ∈ SpecificationRelation then v1 is more specific then v2 in mgv.e.g Paris↦France ∈ locatedIn(Europe)&#10;  @AXM_SRSemantic ∀mgv· mgv ∈ dom(SpecificationRelation) ⇒ SpecificationRelation(mgv)⊆ mgv×mgv //range of SpecificationRelation(mgv)is a subset of cartasian product of elements of NGV. e.g locatedIn(Europe)⊆ Europe×Europe&#10;  @AXM_SR_irreflexivity ∀mgv,a· mgv∈ dom(SpecificationRelation) ∧ a ∈ mgv⇒ a↦a ∉SpecificationRelation(mgv)//SpecificationRelation is irreflexive&#10;  theorem @THM_SR_mgv ∀mgv,a,b· mgv∈ dom(SpecificationRelation) ∧&#10;                      a↦b ∈ SpecificationRelation(mgv)⇒ {a,b}⊆ mgv&#10;  @AXM_SR_transitivity ∀mgv,a,b,c· mgv∈ dom(SpecificationRelation)&#10;                       ∧ a↦b ∈ SpecificationRelation(mgv)∧  b↦c ∈ SpecificationRelation(mgv) ⇒  a↦c ∈ SpecificationRelation(mgv)// SpecificationRelation is transitive&#10;  theorem @thm_spec ∀locatedIn,location· location ⊆ GENERALVALUES∧ location ∈ dom(SpecificationRelation)∧ locatedIn = SpecificationRelation(location)  ⇒ locatedIn ⊆ location×location&#10;  @AXM_SpecificationRelationOnSetsStructure SpecificationRelationOnSets ∈ ℙ(GENERALVALUES) ⇸ ℙ(ℙ(GENERALVALUES) × ℙ(GENERALVALUES))// same as SpecificationRelation but for sets&#10;  @AXM_SRS ∀mgv· mgv ∈ dom(SpecificationRelationOnSets) ⇒ SpecificationRelationOnSets(mgv)⊆ ℙ(mgv)×ℙ(mgv) //  {Paris}↦{France} ∈ locatedInOnSets(Europe) write in natural languages and move this to the c1_test&#10;  @AXM_SRS_SR ∀mgv· mgv ∈ dom(SpecificationRelationOnSets) ⇒ mgv∈dom(SpecificationRelation) // locatedIn&#10;  @AXM_SRS_empty ∀mgv,a,b· mgv ∈ dom(SpecificationRelationOnSets) ∧a↦b∈SpecificationRelationOnSets(mgv)⇒(a≠∅∧ b≠∅) // locatedIn&#10;  @AXM_SpecificationRelationOnSets&#10;  ∀A,B,mgv·   mgv ∈ dom(SpecificationRelationOnSets) ∧ A ⊆ mgv ∧ B⊆ mgv ⇒&#10;                                   ( A↦B ∈ SpecificationRelationOnSets(mgv) ⇔ (&#10;                                   ∀a· a∈ A ⇒ (a∈B ∨ (∃b· b∈B ∧ a↦b ∈ SpecificationRelation(mgv))) ∧&#10;                                   (∃c,d· c∈ A ∧ d ∈ B ∧ c↦d∈ SpecificationRelation(mgv))&#10;                                   )&#10;                                   ) // A ↦ B is element of SpecificationRelationOnSets(mgv) iff for each element of A this element is in B or such element has SpecificationRelation with an element of B&#10;  @AXM_SRS_irreflexivity ∀mgv,a · mgv∈ dom(SpecificationRelationOnSets) ∧ a⊆ mgv ⇒&#10;                         a↦a ∉ SpecificationRelationOnSets(mgv)//SpecificationRelationOnSets is irreflexive&#10;  theorem @THM_SRS_1 ∀mgv,a,b· mgv∈ dom(SpecificationRelationOnSets) ∧&#10;                     a↦b ∈ SpecificationRelationOnSets(mgv)⇒  a⊆ mgv ∧ b⊆ mgv // derived from @AXM_SRS&#10;  @AXM_SRS_transitivity ∀mgv,a,b,c· mgv∈ dom(SpecificationRelationOnSets) ∧ a⊆ mgv ∧ b⊆ mgv ∧ c⊆ mgv&#10;                        ∧ a↦b ∈ SpecificationRelationOnSets(mgv)∧  b↦c ∈ SpecificationRelationOnSets(mgv) ⇒  a↦c ∈ SpecificationRelationOnSets(mgv) //SpecificationRelationOnSets is transitive&#10;  @AXM_getPossibleValuesOfPonCap2 ∀v,p,pe,c·   c ∈ Capability ∧ pe∈c ∧ pe=p↦v⇒&#10;  getPossibleValuesOfPonCapability(c↦p)= v // a more simple definition of getPossibleValuesOfPonCapability e.g getPossibleValuesOfPonPE(cap↦actionCategory)=shipping&#10;  theorem @THM_getPossibleValuesOfPonCapthm ∀p,c·   c ∈ Capability_valid ∧ p∈ getPropertiesForCapability(c)⇒ getPossibleValuesOfPonCapability(c↦p)⊆ hasMGV(p) //value of a property in a valid capability is always included in MGV of such property&#10;  theorem @THM_getPossibleValuesOfPnotEmptyset ∀p,c· c ∈ Capability_valid ∧ p ∈ getPropertiesForCapability(c) ⇒&#10;                                    getPossibleValuesOfPonCapability(c↦p)≠∅ //value of a property in a valid capability is always different of empty set&#10;  theorem @THM_ConditionalValueAndMGV ∀cap,p,p_c,v_c,v_p,v_p2· cap ∈ Capability ∧ {p,p_c}⊆ getPropertiesForCapability(cap)∧ p_c≠p   ∧&#10;                            v_c ⊆ hasMGV(p_c)∧&#10;                            v_p ⊆hasMGV(p)∧v_p2 ⊆hasMGV(p) ⇒&#10;                            CND(cap↦p↦v_p↦v_p2↦condition(cap↦p_c↦v_c))⊆ hasMGV(p)//ConditionalValue is included in MGV if v_c,v_p and v_p2 are included in MGV&#10;  theorem @THM_ConditionalValueNotEmpty ∀cap,p,p_c,v_c,v_p,v_p2· cap ∈ Capability ∧ {p,p_c}⊆ getPropertiesForCapability(cap)∧ p_c≠p   ∧&#10;                            v_c ⊆ hasMGV(p_c)∧&#10;                            v_p ⊆hasMGV(p)∧v_p2 ⊆hasMGV(p)∧ v_p≠∅ ∧v_p2≠∅ ⇒&#10;                            CND(cap↦p↦v_p↦v_p2↦condition(cap↦p_c↦v_c))≠∅ //ConditionalValue is different of empty set if v_p and v_p2 are different of empty set too&#10;&#10;  theorem @THM_FunctionalValuesValues ∀c,p,pf,fn· c ∈ Capability ∧ p ∈  getPropertiesForCapability(c) ∧&#10;                                pf ∈ getPropertiesForCapability(c) ∧ fn∈ f∧ ran(fn) ⊆  hasMGV(p) ∧ p≠pf∧&#10;                       FN(c↦p↦pf↦fn) ⊆ FunctionalValues ⇒     FN(c↦p↦pf↦fn) ⊆ hasMGV(p) //a valid functionalValue is included in MGV&#10;&#10;&#10;&#10;end&#10;" version="3">
    <org.eventb.core.extendsContext name="'" org.eventb.core.target="C0"/>
    <org.eventb.core.constant name="_wRhcoMMaEe-VH7iYn6Ntow" org.eventb.core.comment="relation between twos elements of MGV e.g in locations locatedIn is a SpecificationRelation between two locations Sydney and Australia" org.eventb.core.generated="false" org.eventb.core.identifier="SpecificationRelation"/>
    <org.eventb.core.constant name="_wRiqwMMaEe-VH7iYn6Ntow" org.eventb.core.comment="relation between twos sets of MGV e.g in locations locatedIn is a SpecificationRelation between to locations {Melbourne,Sydney} and {Australia}&#10;this context is used to define specification relation between capability" org.eventb.core.generated="false" org.eventb.core.identifier="SpecificationRelationOnSets"/>
    <org.eventb.core.axiom name="_wRiqwcMaEe-VH7iYn6Ntow" org.eventb.core.comment="SpecificationRelation is a partial relation on an MGV mgv .I v1 and v2 are twos values of mgv and v1↦v2 ∈ SpecificationRelation then v1 is more specific then v2 in mgv.e.g Paris↦France ∈ locatedIn(Europe)" org.eventb.core.generated="false" org.eventb.core.label="AXM_SR" org.eventb.core.predicate="SpecificationRelation ∈ ℙ(GENERALVALUES) ⇸ ℙ(GENERALVALUES × GENERALVALUES)"/>
    <org.eventb.core.axiom name="_9UtpUMMeEe-mAKYQs_Orvw" org.eventb.core.comment="range of SpecificationRelation(mgv)is a subset of cartasian product of elements of NGV. e.g locatedIn(Europe)⊆ Europe×Europe" org.eventb.core.generated="false" org.eventb.core.label="AXM_SRSemantic" org.eventb.core.predicate="∀mgv· mgv ∈ dom(SpecificationRelation) ⇒ SpecificationRelation(mgv)⊆ mgv×mgv"/>
    <org.eventb.core.axiom name="_wRjR0cMaEe-VH7iYn6Ntow" org.eventb.core.comment="SpecificationRelation is irreflexive" org.eventb.core.generated="false" org.eventb.core.label="AXM_SR_irreflexivity" org.eventb.core.predicate="∀mgv,a· mgv∈ dom(SpecificationRelation) ∧ a ∈ mgv⇒ a↦a ∉SpecificationRelation(mgv)"/>
    <org.eventb.core.axiom name="_BkLuYMRnEe-mAKYQs_Orvw" org.eventb.core.generated="false" org.eventb.core.label="THM_SR_mgv" org.eventb.core.predicate="∀mgv,a,b· mgv∈ dom(SpecificationRelation) ∧&#10;                      a↦b ∈ SpecificationRelation(mgv)⇒ {a,b}⊆ mgv" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_wRjR1MMaEe-VH7iYn6Ntow" org.eventb.core.comment="SpecificationRelation is transitive" org.eventb.core.generated="false" org.eventb.core.label="AXM_SR_transitivity" org.eventb.core.predicate="∀mgv,a,b,c· mgv∈ dom(SpecificationRelation)&#10;                       ∧ a↦b ∈ SpecificationRelation(mgv)∧  b↦c ∈ SpecificationRelation(mgv) ⇒  a↦c ∈ SpecificationRelation(mgv)"/>
    <org.eventb.core.axiom name="_wRjR1cMaEe-VH7iYn6Ntow" org.eventb.core.generated="false" org.eventb.core.label="thm_spec" org.eventb.core.predicate="∀locatedIn,location· location ⊆ GENERALVALUES∧ location ∈ dom(SpecificationRelation)∧ locatedIn = SpecificationRelation(location)  ⇒ locatedIn ⊆ location×location" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_8Wpl8MMbEe-mAKYQs_Orvw" org.eventb.core.comment="same as SpecificationRelation but for sets" org.eventb.core.generated="false" org.eventb.core.label="AXM_SpecificationRelationOnSetsStructure" org.eventb.core.predicate="SpecificationRelationOnSets ∈ ℙ(GENERALVALUES) ⇸ ℙ(ℙ(GENERALVALUES) × ℙ(GENERALVALUES))"/>
    <org.eventb.core.axiom name="_wRjR0MMaEe-VH7iYn6Ntow" org.eventb.core.comment="{Paris}↦{France} ∈ locatedInOnSets(Europe) write in natural languages and move this to the c1_test" org.eventb.core.generated="false" org.eventb.core.label="AXM_SRS" org.eventb.core.predicate="∀mgv· mgv ∈ dom(SpecificationRelationOnSets) ⇒ SpecificationRelationOnSets(mgv)⊆ ℙ(mgv)×ℙ(mgv)"/>
    <org.eventb.core.axiom name="_BkMVcMRnEe-mAKYQs_Orvw" org.eventb.core.comment="locatedIn" org.eventb.core.generated="false" org.eventb.core.label="AXM_SRS_SR" org.eventb.core.predicate="∀mgv· mgv ∈ dom(SpecificationRelationOnSets) ⇒ mgv∈dom(SpecificationRelation)"/>
    <org.eventb.core.axiom name="_wRjR1sMaEe-VH7iYn6Ntow" org.eventb.core.comment="locatedIn" org.eventb.core.generated="false" org.eventb.core.label="AXM_SRS_empty" org.eventb.core.predicate="∀mgv,a,b· mgv ∈ dom(SpecificationRelationOnSets) ∧a↦b∈SpecificationRelationOnSets(mgv)⇒(a≠∅∧ b≠∅)"/>
    <org.eventb.core.axiom name="_wRj44MMaEe-VH7iYn6Ntow" org.eventb.core.comment="A ↦ B is element of SpecificationRelationOnSets(mgv) iff for each element of A this element is in B or such element has SpecificationRelation with an element of B" org.eventb.core.generated="false" org.eventb.core.label="AXM_SpecificationRelationOnSets" org.eventb.core.predicate="∀A,B,mgv·   mgv ∈ dom(SpecificationRelationOnSets) ∧ A ⊆ mgv ∧ B⊆ mgv ⇒&#10;                                   ( A↦B ∈ SpecificationRelationOnSets(mgv) ⇔ (&#10;                                   ∀a· a∈ A ⇒ (a∈B ∨ (∃b· b∈B ∧ a↦b ∈ SpecificationRelation(mgv))) ∧&#10;                                   (∃c,d· c∈ A ∧ d ∈ B ∧ c↦d∈ SpecificationRelation(mgv))&#10;                                   )&#10;                                   )"/>
    <org.eventb.core.axiom name="_Sr3oEMRnEe-mAKYQs_Orvw" org.eventb.core.comment="SpecificationRelationOnSets is irreflexive" org.eventb.core.generated="false" org.eventb.core.label="AXM_SRS_irreflexivity" org.eventb.core.predicate="∀mgv,a · mgv∈ dom(SpecificationRelationOnSets) ∧ a⊆ mgv ⇒&#10;                         a↦a ∉ SpecificationRelationOnSets(mgv)"/>
    <org.eventb.core.axiom name="_OmiBUMMdEe-mAKYQs_Orvw" org.eventb.core.comment="derived from @AXM_SRS" org.eventb.core.generated="false" org.eventb.core.label="THM_SRS_1" org.eventb.core.predicate="∀mgv,a,b· mgv∈ dom(SpecificationRelationOnSets) ∧&#10;                     a↦b ∈ SpecificationRelationOnSets(mgv)⇒  a⊆ mgv ∧ b⊆ mgv" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_wRj448MaEe-VH7iYn6Ntow" org.eventb.core.comment="SpecificationRelationOnSets is transitive" org.eventb.core.generated="false" org.eventb.core.label="AXM_SRS_transitivity" org.eventb.core.predicate="∀mgv,a,b,c· mgv∈ dom(SpecificationRelationOnSets) ∧ a⊆ mgv ∧ b⊆ mgv ∧ c⊆ mgv&#10;                        ∧ a↦b ∈ SpecificationRelationOnSets(mgv)∧  b↦c ∈ SpecificationRelationOnSets(mgv) ⇒  a↦c ∈ SpecificationRelationOnSets(mgv)"/>
    <org.eventb.core.axiom name="_D7yRgMfhEe-mAKYQs_Orvw" org.eventb.core.comment="a more simple definition of getPossibleValuesOfPonCapability e.g getPossibleValuesOfPonPE(cap↦actionCategory)=shipping" org.eventb.core.generated="false" org.eventb.core.label="AXM_getPossibleValuesOfPonCap2" org.eventb.core.predicate="∀v,p,pe,c·   c ∈ Capability ∧ pe∈c ∧ pe=p↦v⇒&#10;  getPossibleValuesOfPonCapability(c↦p)= v"/>
    <org.eventb.core.axiom name="_vam9YMfpEe-mAKYQs_Orvw" org.eventb.core.comment="value of a property in a valid capability is always included in MGV of such property" org.eventb.core.generated="false" org.eventb.core.label="THM_getPossibleValuesOfPonCapthm" org.eventb.core.predicate="∀p,c·   c ∈ Capability_valid ∧ p∈ getPropertiesForCapability(c)⇒ getPossibleValuesOfPonCapability(c↦p)⊆ hasMGV(p)" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_Wmvd4MhnEe-mAKYQs_Orvw" org.eventb.core.comment="value of a property in a valid capability is always different of empty set" org.eventb.core.generated="false" org.eventb.core.label="THM_getPossibleValuesOfPnotEmptyset" org.eventb.core.predicate="∀p,c· c ∈ Capability_valid ∧ p ∈ getPropertiesForCapability(c) ⇒&#10;                                    getPossibleValuesOfPonCapability(c↦p)≠∅" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_drUwUMkqEe-mAKYQs_Orvw" org.eventb.core.comment="ConditionalValue is included in MGV if v_c,v_p and v_p2 are included in MGV" org.eventb.core.generated="false" org.eventb.core.label="THM_ConditionalValueAndMGV" org.eventb.core.predicate="∀cap,p,p_c,v_c,v_p,v_p2· cap ∈ Capability ∧ {p,p_c}⊆ getPropertiesForCapability(cap)∧ p_c≠p   ∧&#10;                            v_c ⊆ hasMGV(p_c)∧&#10;                            v_p ⊆hasMGV(p)∧v_p2 ⊆hasMGV(p) ⇒&#10;                            CND(cap↦p↦v_p↦v_p2↦condition(cap↦p_c↦v_c))⊆ hasMGV(p)" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_drVXYMkqEe-mAKYQs_Orvw" org.eventb.core.comment="ConditionalValue is different of empty set if v_p and v_p2 are different of empty set too" org.eventb.core.generated="false" org.eventb.core.label="THM_ConditionalValueNotEmpty" org.eventb.core.predicate="∀cap,p,p_c,v_c,v_p,v_p2· cap ∈ Capability ∧ {p,p_c}⊆ getPropertiesForCapability(cap)∧ p_c≠p   ∧&#10;                            v_c ⊆ hasMGV(p_c)∧&#10;                            v_p ⊆hasMGV(p)∧v_p2 ⊆hasMGV(p)∧ v_p≠∅ ∧v_p2≠∅ ⇒&#10;                            CND(cap↦p↦v_p↦v_p2↦condition(cap↦p_c↦v_c))≠∅" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_GrnhwMz4Ee-Xg8cKYtI5Mw" org.eventb.core.comment="a valid functionalValue is included in MGV" org.eventb.core.generated="false" org.eventb.core.label="THM_FunctionalValuesValues" org.eventb.core.predicate="∀c,p,pf,fn· c ∈ Capability ∧ p ∈  getPropertiesForCapability(c) ∧&#10;                                pf ∈ getPropertiesForCapability(c) ∧ fn∈ f∧ ran(fn) ⊆  hasMGV(p) ∧ p≠pf∧&#10;                       FN(c↦p↦pf↦fn) ⊆ FunctionalValues ⇒     FN(c↦p↦pf↦fn) ⊆ hasMGV(p)" org.eventb.core.theorem="true"/>
</org.eventb.core.contextFile>
