<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<org.eventb.core.contextFile org.eventb.core.configuration="org.eventb.core.fwd;de.prob.symbolic.ctxBase" org.eventb.core.generated="false" org.eventb.texttools.text_lastmodified="1741010413286" org.eventb.texttools.text_representation="context VariantOf extends C1&#10;&#10;constants specifies // specifies // check if a value v1 is more specific than a value v2 of the same property&#10;          variantOf // variantOf // check if a capability is variantof another one allowing structure indexation of capabilities&#10;          capabilityExtension // the extension of a capability by another one&#10;        //  specifies_C //specifies between capabilities&#10;        //  extends_C //extends between capabilities&#10;axioms&#10;  @AXM_specifiesStructure specifies ∈ PROPERTY × Capability_valid × ℙ(GENERALVALUES)  ↔&#10;  Capability_valid × ℙ(GENERALVALUES) // relation that determine if a value specifies another one&#10;  @AXM_specifies ∀p,c1,v1,c2,v2· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid ∧&#10;  v1 ⊆ hasMGV(p) ∧ v2 ⊆ hasMGV(p) ∧&#10;                 p ∈ getPropertiesForCapability(c1)∩getPropertiesForCapability(c2)⇒(&#10;                 (p↦c1↦v1)↦(c2↦v2) ∈ specifies   ⇔ ( v1⊂v2  ∨&#10;                 (hasMGV(p)∈ dom(SpecificationRelationOnSets)∧&#10;                 v1↦v2∈ SpecificationRelationOnSets(hasMGV(p))) ) )&#10;                  /* if p is a property in twos valid capabilities c1 and c2 and value of p in c1 and c2 is v1 and v2 then&#10;                  (p↦c1↦v1)↦(c2↦v2) ∈ specifies iff v1 in included in v2 or MGV of p is element of dom(SpecificationRelationOnSets)and&#10;                 v1↦v2 ∈ SpecificationRelationOnSets(hasMGV(p) */&#10;  @AXM_specifies_inclusionOrRelationCoexistence ∀p· p ∈ PROPERTY ∧  hasMGV(p) ∈ dom(SpecificationRelationOnSets)∧&#10;                                                (∃v1,v2· v1↦v2  ∈ SpecificationRelationOnSets(hasMGV(p))) ⇒ (∀v3,v4·&#10;                                                v3 ⊆ hasMGV(p) ∧ v4 ⊆ hasMGV(p) ⇒ ¬(v3⊂v4))&#10;  /* for any property p for which the MGV is element of domain(SpecificationRelationOnSets) and if there exists at least twos set of values v1 and v2 where&#10;  v1↦v2  ∈ SpecificationRelationOnSets(hasMGV(p))) then we can say that for all element of the MGV(p) there cannot be an inclusion between them&#10;  p=location ∧ hasMGV(location)=Geo ∧ Geo ∈ dom(SpecificationRelationOnSets)∧&#10;     locatedIn=SpecificationRelationOnSets(Geo) ∧ {paris}↦{France} ∈ locatedIn ⇒  v3= {paris} ⊆ Geo ∧ v4= {France}⊆Geo ∧ Not {paris} ⊂  {France}&#10;     For properties in an MGV  inclusion and SpecificationRelationOnSets cannot coexist */&#10;  @AXM_capabilityExtensionStructure capabilityExtension ∈ Capability_valid × Capability_valid → Capability_valid // We say that capabilityExtension(B↦A) is the extension of B by A&#10;  @AXM_capabilityExtension ∀B,A· A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                           getPropertiesForCapability(B)⊆getPropertiesForCapability(A)&#10;                           ⇒&#10;                           capabilityExtension(B↦A)= B∪{p·p∈(getPropertiesForCapability(A)∖&#10;                           getPropertiesForCapability(B) )∣p↦hasMGV(p)} // capabilityExtension(B↦A) (C_B/A) is B extended by the properties of A that do not belongs to B&#10;  @AXM_variantOfStructure variantOf ∈ Capability_valid ↔ Capability_valid // partial order between capabilities&#10;  @AXM_variantOf ∀ A,B· A ∈ Capability_valid ∧ B ∈  Capability_valid ∧&#10;                 getPropertiesForCapability(B)⊆getPropertiesForCapability(A)⇒&#10;                 (A↦B∈variantOf   ⇔&#10;                 (&#10;                 getPossibleValuesOfPonCapability(A↦actionCategory)=&#10;                 getPossibleValuesOfPonCapability(B↦actionCategory)&#10;                 ∧&#10;                 (&#10;                 ∀p,v_p_A,v_p_BextA· p∈ getPropertiesForCapability(A) ∧&#10;                 v_p_A= getPossibleValuesOfPonCapability(A↦p) ∧&#10;                 v_p_BextA= getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p) ⇒&#10;                 (v_p_A=v_p_BextA ∨  (p↦A↦v_p_A)↦(capabilityExtension(B↦A)↦v_p_BextA) ∈ specifies)&#10;                 ) ∧&#10;                 (∃p0·p0 ∈ getPropertiesForCapability(A) ∧ (p0↦A↦getPossibleValuesOfPonCapability(A↦p0))↦(capabilityExtension(B↦A)↦getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p0)) ∈ specifies)&#10;                 )&#10;                 )  /* A is variantOf B iff i) they have the same actionCategory;&#10;                 ii)(For all properties p of A the value of p is either equal or&#10;                 specifies its value in C_B/A iii) there exist at least one property of A that&#10;                 specifies its value in C_B/A )*/&#10;  theorem @THM_specifiesirreflexive ∀c1,v1,p·  c1 ∈ Capability_valid ∧  p∈getPropertiesForCapability(c1) ∧ v1 ⊆hasMGV(p) ∧ v1≠∅ ⇒ (p↦c1↦v1)↦(c1↦v1)∉specifies // specifies is irreflexive&#10;  theorem @THM_variantOf_irreflexivity ∀c· c ∈ Capability_valid⇒ c↦c ∉ variantOf//variantOf irreflexivity&#10;  theorem @THM_specifiestransitivity ∀c1,c2,c3,v1,v2,v3,p·  c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid ∧ c3 ∈ Capability_valid ∧&#10;                                     p ∈ getPropertiesForCapability(c1)∩getPropertiesForCapability(c2)∩getPropertiesForCapability(c3)∧&#10;                                     v1 ⊆hasMGV(p) ∧ v2 ⊆hasMGV(p) ∧ v3 ⊆hasMGV(p) ∧ (p↦c1↦v1)↦(c2↦v2) ∈ specifies ∧ (p↦c2↦v2)↦(c3↦v3) ∈ specifies ⇒ (p↦c1↦v1)↦(c3↦v3) ∈ specifies //specifies transitivity&#10;  theorem @THM_CapabilityExtensionPossibleVal ∀A,B,p·  A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                                              getPropertiesForCapability(B)⊆getPropertiesForCapability(A) ⇒&#10;                                             ( p ∈ getPropertiesForCapability(B) ⇒ getPossibleValuesOfPonCapability(B↦p)=getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p)&#10;                                              ) // if p is element of B properties then the value of p in B is the same value in capabilityExtension(B↦A)&#10;  theorem @THM_CapabilityExtensionPossibleProperties ∀A,B,p·  A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                                                     getPropertiesForCapability(B)⊆getPropertiesForCapability(A) ⇒&#10;                                                     ( p ∈ getPropertiesForCapability(B) ∨ p ∈ getPropertiesForCapability(A) ⇒  p ∈ getPropertiesForCapability(capabilityExtension(B↦A))&#10;                                                     )//if p is in the properties of B or A then p is a prpoerty of capabilityExtension(B↦A)&#10;  theorem @THM_specifieswithCapabilityExtension ∀A,B,p·  A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                        getPropertiesForCapability(B)⊆getPropertiesForCapability(A) ∧&#10;                        p ∈ getPropertiesForCapability(A)∧ p∈ getPropertiesForCapability(B) ∧&#10;                        (p↦A↦getPossibleValuesOfPonCapability(A↦p))↦(capabilityExtension(B↦A)↦getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p)) ∈ specifies&#10;                        ⇒ (p↦A↦getPossibleValuesOfPonCapability(A↦p))↦(B↦getPossibleValuesOfPonCapability(B↦p)) ∈ specifies// if value of p in A specifies value of p in capabilityExtension(B↦A) then value of p in A specifies value of p in B&#10;  theorem @THM_specifieswithCapabilityExtension2 ∀A,B,p·  A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                                                 getPropertiesForCapability(B)⊆getPropertiesForCapability(A) ∧&#10;                                                 p ∈ getPropertiesForCapability(A) ⇒(&#10;                                                 getPossibleValuesOfPonCapability(A↦p)= getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p) ⇒&#10;                                                 (getPossibleValuesOfPonCapability(A↦p)=getPossibleValuesOfPonCapability(B↦p) ∧&#10;                                                 p∈ getPropertiesForCapability(B))  ∨&#10;                                                 (getPossibleValuesOfPonCapability(A↦p)=hasMGV(p) ∧ p∉ getPropertiesForCapability(B))&#10;                                                 )/* if p is a property of A and value of p in A equals its value in capabilityExtension(B↦A)&#10;                                                 then either p is a property of B and value of p in A is the same as its value in B or p is not a property of B and value of p in A equals hasMGV(p)*/&#10;  theorem @THM_specifieswithCapabilityExtension3 ∀A,B,p·  A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                                                 getPropertiesForCapability(B)⊆getPropertiesForCapability(A) ∧&#10;                                                 p ∈ getPropertiesForCapability(A) ⇒(&#10;                                                 getPossibleValuesOfPonCapability(A↦p)=  hasMGV(p) ∧ p∉ getPropertiesForCapability(B) ⇒&#10;                                                 getPossibleValuesOfPonCapability(A↦p)= getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p)&#10;                                                 ) /*if p is a property of A and p is not a property of B and value of p in A equals hasMGV(p) then&#10;                                                 value of p in A equals its value in capabilityExtension(B↦A) */&#10;  theorem @THM_specifieswithCapabilityExtensionValueP ∀A,B·  A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                                                      getPropertiesForCapability(B)⊆getPropertiesForCapability(A) ⇒(&#10;                                                      ∀p· p ∉ getPropertiesForCapability(B) ∧ p∈ getPropertiesForCapability(capabilityExtension(B↦A))⇒&#10;                                                      getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p) = hasMGV(p)) /*&#10;                                                   if p is in a property of B and p is property of capabilityExtension(B↦A) then value of p in capabilityExtension(B↦A) equals hasMGV(p)*/&#10;  theorem @THM_specifies2 ∀p,c1,v1,c2,v2,c3,c4· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid ∧&#10;                          c3 ∈ Capability_valid ∧  c4 ∈ Capability_valid ∧ v1 ⊆ hasMGV(p) ∧ v2 ⊆ hasMGV(p) ∧&#10;                          p ∈ getPropertiesForCapability(c1)∧p∈getPropertiesForCapability(c2) ∧&#10;                          p∈getPropertiesForCapability(c3)∧  p∈getPropertiesForCapability(c4)&#10;                          ⇒ ((p↦c1↦v1)↦(c2↦v2) ∈ specifies⇒ (p↦c3↦v1)↦(c4↦v2) ∈ specifies ) /*&#10;                          if p is a property in c1,c2,c3 and c4 and v1 specifies v2 on c1 and c2 then v1 still specifies v2 on c3and  c4*/&#10; theorem @THM_specifiesofEnumerationValue1 ∀c1,c2,p,S· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid  ∧&#10;                                            p ∈ getPropertiesForCapability(c1)∩getPropertiesForCapability(c2)    ∧ S⊆ ℙ(possibleValues)∧&#10;                                            getPossibleValuesOfPonCapability(c2↦p) = Enum(S) ∧ getPossibleValuesOfPonCapability(c2↦p)≠getPossibleValuesOfPonCapability(c1↦p)&#10;                                            ⇒&#10;                                            (     (∀v· v ∈ getPossibleValuesOfPonCapability(c2↦p)   ⇒&#10;                                            (p↦c2↦{v})↦(c1↦getPossibleValuesOfPonCapability(c1↦p)) ∈ specifies ) ⇒&#10;                                            (p↦c2↦getPossibleValuesOfPonCapability(c2↦p))↦(c1↦getPossibleValuesOfPonCapability(c1↦p)) ∈ specifies&#10;                                            ) /* if p is property in c1 and c2 and value of p in c2 is an enumerationvalue(v2) then if for each element v in v2 {v} specifies the value of p in c1(v1) then v2 specifies v1 */&#10;  theorem @THM_variantOf_transitivity ∀c1,c2,c3· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid ∧&#10;                                      getPropertiesForCapability(c2)⊆getPropertiesForCapability(c1)∧&#10;                                      c3 ∈ Capability_valid ∧  getPropertiesForCapability(c3)⊆getPropertiesForCapability(c2)∧&#10;                                        c1↦c2 ∈ variantOf ∧  c2↦c3∈variantOf ⇒ c1↦c3 ∈ variantOf// variantOf transitivity&#10;    @AXM_specifiesofConditionalValue2 ∀c1,c2,p,p_c,v_c,v_p,v_p2,v1,v2· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid  ∧&#10;                                    p_c≠p ∧&#10;                                    {p,p_c}⊆ getPropertiesForCapability(c1)∩getPropertiesForCapability(c2)    ∧&#10;                                    v_c ⊆ hasMGV(p_c) ∧ v_p ⊆hasMGV(p) ∧ v_p2 ⊆hasMGV(p)∧&#10;                                    v1 = getPossibleValuesOfPonCapability(c1↦p) ∧ v1=CND(c1↦p↦v_p↦v_p2↦condition(c1↦p_c↦v_c))  ∧&#10;                                    v2 = getPossibleValuesOfPonCapability(c2↦p) ∧&#10;                                    condition(c2↦p_c↦v_c)=TRUE  ∧&#10;                                    (p↦c2↦v2)↦(c1↦v_p)∈specifies ⇒ (p↦c2↦v2)↦(c1↦v1) ∈ specifies//if v1 is a conditionalvalue and condition holds for c2 and v2 specifies v_p then v2 specifies v1&#10;//     inference rule R4 when non conditionalValue specifies a conditionalValue */&#10;  theorem @THM_specifiesofConditionalValue ∀c1,c2,p,p_c,v_c,v_p,v_p2,v1,v2· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid  ∧&#10;                           p_c≠p ∧&#10;                           {p,p_c}⊆ getPropertiesForCapability(c1)∩getPropertiesForCapability(c2) ∧&#10;                           v_c ⊆ hasMGV(p_c) ∧&#10;                           v_p ⊆hasMGV(p) ∧ v_p2 ⊆hasMGV(p) ∧&#10;                           v1 = getPossibleValuesOfPonCapability(c1↦p) ∧ v1=CND(c1↦p↦v_p↦v_p2↦condition(c1↦p_c↦v_c))  ∧&#10;                           v2 = getPossibleValuesOfPonCapability(c2↦p)∧&#10;                           condition(c1↦p_c↦v_c)=TRUE ∧ getPossibleValuesOfPonCapability(c2↦p_c)⊆ v_c ∧&#10;                           v2 ⊂ v_p ⇒ (p↦c2↦v2)↦(c1↦v1) ∈ specifies// if v1 a conditionalvalue and condition holds for c1 and v2 &lt;: v_p then v2 specifies v1&#10;  @AXM_specifiesofConditionalValue3 ∀c1,c2,p,p_c,v_c,v_p,v_p2,v1,v2· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid  ∧&#10;                                    p_c≠p ∧&#10;                                    {p,p_c}⊆ getPropertiesForCapability(c1)∩getPropertiesForCapability(c2)    ∧&#10;                                    v_c ⊆ hasMGV(p_c)  ∧&#10;                                    v_p ⊆hasMGV(p)∧ v_p2 ⊆hasMGV(p) ∧&#10;                                    v1 = getPossibleValuesOfPonCapability(c1↦p) ∧ v1=CND(c1↦p↦v_p↦v_p2↦condition(c1↦p_c↦v_c))  ∧&#10;                                    v2 = getPossibleValuesOfPonCapability(c2↦p) ∧&#10;                                    condition(c2↦p_c↦v_c)=FALSE  ∧&#10;                                    v2 ⊂ v_p2 ⇒ (p↦c2↦v2)↦(c1↦v1) ∈ specifies//if v1 is a conditionalvalue and condition does not holds for c2 and  v2 &lt;: v_p then v2 specifies v1&#10;//     inference rule R4 when non conditionalValue specifies a conditionalValue */&#10;&#10;&#10;  @AXM_variantOf_condition ∀c1,c2· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid ⇒(&#10;                             getPropertiesForCapability(c2)⊈getPropertiesForCapability(c1)⇒&#10;                                c1↦c2 ∉  variantOf )// A is variantOf B =&gt;getPropertiesForCapability(c2)⊆getPropertiesForCapability(c1)&#10; //theorem @THM_variantOf_Asymmetric ∀ c1,c2,c3,r· c1 ∈ Capability_valid ∧&#10;  //c2 ∈ Capability_valid ∧ c3 ∈ Capability_valid ∧ r ∈ Capability_valid ↔ Capability_valid  ∧ c1↦c1∉ r ∧&#10;    //(c1↦c2 ∈r ∧ c2↦c3∈r ⇒c1↦c3∈r)⇒ (c1↦c2 ∈r ⇒c2↦c1∉r)&#10;end&#10;" version="3">
    <org.eventb.core.extendsContext name="_NuyL4MMbEe-VH7iYn6Ntow" org.eventb.core.target="C1"/>
    <org.eventb.core.axiom name="_kAnQgLCWEe-1rPj0DjDWfg" org.eventb.core.comment="relation that determine if a value specifies another one" org.eventb.core.generated="false" org.eventb.core.label="AXM_specifiesStructure" org.eventb.core.predicate="specifies ∈ PROPERTY × Capability_valid × ℙ(GENERALVALUES)  ↔&#10;  Capability_valid × ℙ(GENERALVALUES)"/>
    <org.eventb.core.axiom name="_kAn3kLCWEe-1rPj0DjDWfg" org.eventb.core.comment="if p is a property in twos valid capabilities c1 and c2 and value of p in c1 and c2 is v1 and v2 then&#10;                  (p↦c1↦v1)↦(c2↦v2) ∈ specifies iff v1 in included in v2 or MGV of p is element of dom(SpecificationRelationOnSets)and&#10;                 v1↦v2 ∈ SpecificationRelationOnSets(hasMGV(p) " org.eventb.core.generated="false" org.eventb.core.label="AXM_specifies" org.eventb.core.predicate="∀p,c1,v1,c2,v2· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid ∧&#10;  v1 ⊆ hasMGV(p) ∧ v2 ⊆ hasMGV(p) ∧&#10;                 p ∈ getPropertiesForCapability(c1)∩getPropertiesForCapability(c2)⇒(&#10;                 (p↦c1↦v1)↦(c2↦v2) ∈ specifies   ⇔ ( v1⊂v2  ∨&#10;                 (hasMGV(p)∈ dom(SpecificationRelationOnSets)∧&#10;                 v1↦v2∈ SpecificationRelationOnSets(hasMGV(p))) ) )"/>
    <org.eventb.core.constant name="_kAoeoLCWEe-1rPj0DjDWfg" org.eventb.core.comment="specifies // check if a value v1 is more specific than a value v2 of the same property" org.eventb.core.generated="false" org.eventb.core.identifier="specifies"/>
    <org.eventb.core.constant name="_oD3DgLCWEe-1rPj0DjDWfg" org.eventb.core.comment="variantOf // check if a capability is variantof another one allowing structure indexation of capabilities" org.eventb.core.generated="false" org.eventb.core.identifier="variantOf"/>
    <org.eventb.core.axiom name="_DcL2oM3PEe-4uPCSmF3rKA" org.eventb.core.comment="for any property p for which the MGV is element of domain(SpecificationRelationOnSets) and if there exists at least twos set of values v1 and v2 where&#10;  v1↦v2  ∈ SpecificationRelationOnSets(hasMGV(p))) then we can say that for all element of the MGV(p) there cannot be an inclusion between them&#10;  p=location ∧ hasMGV(location)=Geo ∧ Geo ∈ dom(SpecificationRelationOnSets)∧&#10;     locatedIn=SpecificationRelationOnSets(Geo) ∧ {paris}↦{France} ∈ locatedIn ⇒  v3= {paris} ⊆ Geo ∧ v4= {France}⊆Geo ∧ Not {paris} ⊂  {France}&#10;     For properties in an MGV  inclusion and SpecificationRelationOnSets cannot coexist " org.eventb.core.generated="false" org.eventb.core.label="AXM_specifies_inclusionOrRelationCoexistence" org.eventb.core.predicate="∀p· p ∈ PROPERTY ∧  hasMGV(p) ∈ dom(SpecificationRelationOnSets)∧&#10;                                                (∃v1,v2· v1↦v2  ∈ SpecificationRelationOnSets(hasMGV(p))) ⇒ (∀v3,v4·&#10;                                                v3 ⊆ hasMGV(p) ∧ v4 ⊆ hasMGV(p) ⇒ ¬(v3⊂v4))"/>
    <org.eventb.core.axiom name="_zITM4LL9Ee-1rPj0DjDWfg" org.eventb.core.comment="We say that capabilityExtension(B↦A) is the extension of B by A" org.eventb.core.generated="false" org.eventb.core.label="AXM_capabilityExtensionStructure" org.eventb.core.predicate="capabilityExtension ∈ Capability_valid × Capability_valid → Capability_valid"/>
    <org.eventb.core.axiom name="_zITz8LL9Ee-1rPj0DjDWfg" org.eventb.core.comment="capabilityExtension(B↦A) (C_B/A) is B extended by the properties of A that do not belongs to B" org.eventb.core.generated="false" org.eventb.core.label="AXM_capabilityExtension" org.eventb.core.predicate="∀B,A· A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                           getPropertiesForCapability(B)⊆getPropertiesForCapability(A)&#10;                           ⇒&#10;                           capabilityExtension(B↦A)= B∪{p·p∈(getPropertiesForCapability(A)∖&#10;                           getPropertiesForCapability(B) )∣p↦hasMGV(p)}"/>
    <org.eventb.core.axiom name="_oD3DgbCWEe-1rPj0DjDWfg" org.eventb.core.comment="partial order between capabilities" org.eventb.core.generated="false" org.eventb.core.label="AXM_variantOfStructure" org.eventb.core.predicate="variantOf ∈ Capability_valid ↔ Capability_valid"/>
    <org.eventb.core.axiom name="_oD3DgrCWEe-1rPj0DjDWfg" org.eventb.core.comment="A is variantOf B iff i) they have the same actionCategory;&#10;                 ii)(For all properties p of A the value of p is either equal or&#10;                 specifies its value in C_B/A iii) there exist at least one property of A that&#10;                 specifies its value in C_B/A )" org.eventb.core.generated="false" org.eventb.core.label="AXM_variantOf" org.eventb.core.predicate="∀ A,B· A ∈ Capability_valid ∧ B ∈  Capability_valid ∧&#10;                 getPropertiesForCapability(B)⊆getPropertiesForCapability(A)⇒&#10;                 (A↦B∈variantOf   ⇔&#10;                 (&#10;                 getPossibleValuesOfPonCapability(A↦actionCategory)=&#10;                 getPossibleValuesOfPonCapability(B↦actionCategory)&#10;                 ∧&#10;                 (&#10;                 ∀p,v_p_A,v_p_BextA· p∈ getPropertiesForCapability(A) ∧&#10;                 v_p_A= getPossibleValuesOfPonCapability(A↦p) ∧&#10;                 v_p_BextA= getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p) ⇒&#10;                 (v_p_A=v_p_BextA ∨  (p↦A↦v_p_A)↦(capabilityExtension(B↦A)↦v_p_BextA) ∈ specifies)&#10;                 ) ∧&#10;                 (∃p0·p0 ∈ getPropertiesForCapability(A) ∧ (p0↦A↦getPossibleValuesOfPonCapability(A↦p0))↦(capabilityExtension(B↦A)↦getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p0)) ∈ specifies)&#10;                 )&#10;                 )"/>
    <org.eventb.core.axiom name="_krgn0K5KEe-1rPj0DjDWfg" org.eventb.core.comment="specifies is irreflexive" org.eventb.core.generated="false" org.eventb.core.label="THM_specifiesirreflexive" org.eventb.core.predicate="∀c1,v1,p·  c1 ∈ Capability_valid ∧  p∈getPropertiesForCapability(c1) ∧ v1 ⊆hasMGV(p) ∧ v1≠∅ ⇒ (p↦c1↦v1)↦(c1↦v1)∉specifies" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_al9pUMhjEe-mAKYQs_Orvw" org.eventb.core.comment="variantOf irreflexivity" org.eventb.core.generated="false" org.eventb.core.label="THM_variantOf_irreflexivity" org.eventb.core.predicate="∀c· c ∈ Capability_valid⇒ c↦c ∉ variantOf" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_7DdPUK5MEe-1rPj0DjDWfg" org.eventb.core.comment="specifies transitivity" org.eventb.core.generated="false" org.eventb.core.label="THM_specifiestransitivity" org.eventb.core.predicate="∀c1,c2,c3,v1,v2,v3,p·  c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid ∧ c3 ∈ Capability_valid ∧&#10;                                     p ∈ getPropertiesForCapability(c1)∩getPropertiesForCapability(c2)∩getPropertiesForCapability(c3)∧&#10;                                     v1 ⊆hasMGV(p) ∧ v2 ⊆hasMGV(p) ∧ v3 ⊆hasMGV(p) ∧ (p↦c1↦v1)↦(c2↦v2) ∈ specifies ∧ (p↦c2↦v2)↦(c3↦v3) ∈ specifies ⇒ (p↦c1↦v1)↦(c3↦v3) ∈ specifies" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_rLS0QOHHEe-OnJfusbHiIA" org.eventb.core.comment="if p is element of B properties then the value of p in B is the same value in capabilityExtension(B↦A)" org.eventb.core.generated="false" org.eventb.core.label="THM_CapabilityExtensionPossibleVal" org.eventb.core.predicate="∀A,B,p·  A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                                              getPropertiesForCapability(B)⊆getPropertiesForCapability(A) ⇒&#10;                                             ( p ∈ getPropertiesForCapability(B) ⇒ getPossibleValuesOfPonCapability(B↦p)=getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p)&#10;                                              )" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_rLTbUOHHEe-OnJfusbHiIA" org.eventb.core.comment="if p is in the properties of B or A then p is a prpoerty of capabilityExtension(B↦A)" org.eventb.core.generated="false" org.eventb.core.label="THM_CapabilityExtensionPossibleProperties" org.eventb.core.predicate="∀A,B,p·  A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                                                     getPropertiesForCapability(B)⊆getPropertiesForCapability(A) ⇒&#10;                                                     ( p ∈ getPropertiesForCapability(B) ∨ p ∈ getPropertiesForCapability(A) ⇒  p ∈ getPropertiesForCapability(capabilityExtension(B↦A))&#10;                                                     )" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_WxUcYM-dEe-8p_pZ6KAIYg" org.eventb.core.comment="if value of p in A specifies value of p in capabilityExtension(B↦A) then value of p in A specifies value of p in B" org.eventb.core.generated="false" org.eventb.core.label="THM_specifieswithCapabilityExtension" org.eventb.core.predicate="∀A,B,p·  A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                        getPropertiesForCapability(B)⊆getPropertiesForCapability(A) ∧&#10;                        p ∈ getPropertiesForCapability(A)∧ p∈ getPropertiesForCapability(B) ∧&#10;                        (p↦A↦getPossibleValuesOfPonCapability(A↦p))↦(capabilityExtension(B↦A)↦getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p)) ∈ specifies&#10;                        ⇒ (p↦A↦getPossibleValuesOfPonCapability(A↦p))↦(B↦getPossibleValuesOfPonCapability(B↦p)) ∈ specifies" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_q2gI4NAUEe-nhKCIhkAb_g" org.eventb.core.comment="if p is a property of A and value of p in A equals its value in capabilityExtension(B↦A)&#10;                                                 then either p is a property of B and value of p in A is the same as its value in B or p is not a property of B and value of p in A equals hasMGV(p)" org.eventb.core.generated="false" org.eventb.core.label="THM_specifieswithCapabilityExtension2" org.eventb.core.predicate="∀A,B,p·  A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                                                 getPropertiesForCapability(B)⊆getPropertiesForCapability(A) ∧&#10;                                                 p ∈ getPropertiesForCapability(A) ⇒(&#10;                                                 getPossibleValuesOfPonCapability(A↦p)= getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p) ⇒&#10;                                                 (getPossibleValuesOfPonCapability(A↦p)=getPossibleValuesOfPonCapability(B↦p) ∧&#10;                                                 p∈ getPropertiesForCapability(B))  ∨&#10;                                                 (getPossibleValuesOfPonCapability(A↦p)=hasMGV(p) ∧ p∉ getPropertiesForCapability(B))&#10;                                                 )" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_6RiaQNBmEe-nhKCIhkAb_g" org.eventb.core.comment="if p is a property of A and p is not a property of B and value of p in A equals hasMGV(p) then&#10;                                                 value of p in A equals its value in capabilityExtension(B↦A) " org.eventb.core.generated="false" org.eventb.core.label="THM_specifieswithCapabilityExtension3" org.eventb.core.predicate="∀A,B,p·  A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                                                 getPropertiesForCapability(B)⊆getPropertiesForCapability(A) ∧&#10;                                                 p ∈ getPropertiesForCapability(A) ⇒(&#10;                                                 getPossibleValuesOfPonCapability(A↦p)=  hasMGV(p) ∧ p∉ getPropertiesForCapability(B) ⇒&#10;                                                 getPossibleValuesOfPonCapability(A↦p)= getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p)&#10;                                                 )" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_0tjeENH3Ee-dH5qQWQw4VQ" org.eventb.core.comment="&#10;                                                   if p is in a property of B and p is property of capabilityExtension(B↦A) then value of p in capabilityExtension(B↦A) equals hasMGV(p)" org.eventb.core.generated="false" org.eventb.core.label="THM_specifieswithCapabilityExtensionValueP" org.eventb.core.predicate="∀A,B·  A ∈ Capability_valid ∧ B ∈ Capability_valid ∧&#10;                                                      getPropertiesForCapability(B)⊆getPropertiesForCapability(A) ⇒(&#10;                                                      ∀p· p ∉ getPropertiesForCapability(B) ∧ p∈ getPropertiesForCapability(capabilityExtension(B↦A))⇒&#10;                                                      getPossibleValuesOfPonCapability(capabilityExtension(B↦A)↦p) = hasMGV(p))" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_y5LbENWUEe-uSJA-7DlAAw" org.eventb.core.comment="&#10;                          if p is a property in c1,c2,c3 and c4 and v1 specifies v2 on c1 and c2 then v1 still specifies v2 on c3and  c4" org.eventb.core.generated="false" org.eventb.core.label="THM_specifies2" org.eventb.core.predicate="∀p,c1,v1,c2,v2,c3,c4· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid ∧&#10;                          c3 ∈ Capability_valid ∧  c4 ∈ Capability_valid ∧ v1 ⊆ hasMGV(p) ∧ v2 ⊆ hasMGV(p) ∧&#10;                          p ∈ getPropertiesForCapability(c1)∧p∈getPropertiesForCapability(c2) ∧&#10;                          p∈getPropertiesForCapability(c3)∧  p∈getPropertiesForCapability(c4)&#10;                          ⇒ ((p↦c1↦v1)↦(c2↦v2) ∈ specifies⇒ (p↦c3↦v1)↦(c4↦v2) ∈ specifies )" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_NqrVQNciEe-uSJA-7DlAAw" org.eventb.core.comment="if p is property in c1 and c2 and value of p in c2 is an enumerationvalue(v2) then if for each element v in v2 {v} specifies the value of p in c1(v1) then v2 specifies v1 " org.eventb.core.generated="false" org.eventb.core.label="THM_specifiesofEnumerationValue1" org.eventb.core.predicate="∀c1,c2,p,S· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid  ∧&#10;                                            p ∈ getPropertiesForCapability(c1)∩getPropertiesForCapability(c2)    ∧ S⊆ ℙ(possibleValues)∧&#10;                                            getPossibleValuesOfPonCapability(c2↦p) = Enum(S) ∧ getPossibleValuesOfPonCapability(c2↦p)≠getPossibleValuesOfPonCapability(c1↦p)&#10;                                            ⇒&#10;                                            (     (∀v· v ∈ getPossibleValuesOfPonCapability(c2↦p)   ⇒&#10;                                            (p↦c2↦{v})↦(c1↦getPossibleValuesOfPonCapability(c1↦p)) ∈ specifies ) ⇒&#10;                                            (p↦c2↦getPossibleValuesOfPonCapability(c2↦p))↦(c1↦getPossibleValuesOfPonCapability(c1↦p)) ∈ specifies&#10;                                            )" org.eventb.core.theorem="true"/>
    <org.eventb.core.constant name="_zITz8bL9Ee-1rPj0DjDWfg" org.eventb.core.comment="the extension of a capability by another one&#10;specifies_C //specifies between capabilities&#10;extends_C //extends between capabilities" org.eventb.core.generated="false" org.eventb.core.identifier="capabilityExtension"/>
    <org.eventb.core.axiom name="_PvNkgOHFEe-OnJfusbHiIA" org.eventb.core.comment="variantOf transitivity" org.eventb.core.generated="false" org.eventb.core.label="THM_variantOf_transitivity" org.eventb.core.predicate="∀c1,c2,c3· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid ∧&#10;                                      getPropertiesForCapability(c2)⊆getPropertiesForCapability(c1)∧&#10;                                      c3 ∈ Capability_valid ∧  getPropertiesForCapability(c3)⊆getPropertiesForCapability(c2)∧&#10;                                        c1↦c2 ∈ variantOf ∧  c2↦c3∈variantOf ⇒ c1↦c3 ∈ variantOf" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_CQtzUOGqEe-OnJfusbHiIA" org.eventb.core.comment="if v1 is a conditionalvalue and condition holds for c2 and v2 specifies v_p then v2 specifies v1&#10;inference rule R4 when non conditionalValue specifies a conditionalValue */" org.eventb.core.generated="false" org.eventb.core.label="AXM_specifiesofConditionalValue2" org.eventb.core.predicate="∀c1,c2,p,p_c,v_c,v_p,v_p2,v1,v2· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid  ∧&#10;                                    p_c≠p ∧&#10;                                    {p,p_c}⊆ getPropertiesForCapability(c1)∩getPropertiesForCapability(c2)    ∧&#10;                                    v_c ⊆ hasMGV(p_c) ∧ v_p ⊆hasMGV(p) ∧ v_p2 ⊆hasMGV(p)∧&#10;                                    v1 = getPossibleValuesOfPonCapability(c1↦p) ∧ v1=CND(c1↦p↦v_p↦v_p2↦condition(c1↦p_c↦v_c))  ∧&#10;                                    v2 = getPossibleValuesOfPonCapability(c2↦p) ∧&#10;                                    condition(c2↦p_c↦v_c)=TRUE  ∧&#10;                                    (p↦c2↦v2)↦(c1↦v_p)∈specifies ⇒ (p↦c2↦v2)↦(c1↦v1) ∈ specifies"/>
    <org.eventb.core.axiom name="_CQvBcOGqEe-OnJfusbHiIA" org.eventb.core.comment="if v1 a conditionalvalue and condition holds for c1 and v2 &lt;: v_p then v2 specifies v1" org.eventb.core.generated="false" org.eventb.core.label="THM_specifiesofConditionalValue" org.eventb.core.predicate="∀c1,c2,p,p_c,v_c,v_p,v_p2,v1,v2· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid  ∧&#10;                           p_c≠p ∧&#10;                           {p,p_c}⊆ getPropertiesForCapability(c1)∩getPropertiesForCapability(c2) ∧&#10;                           v_c ⊆ hasMGV(p_c) ∧&#10;                           v_p ⊆hasMGV(p) ∧ v_p2 ⊆hasMGV(p) ∧&#10;                           v1 = getPossibleValuesOfPonCapability(c1↦p) ∧ v1=CND(c1↦p↦v_p↦v_p2↦condition(c1↦p_c↦v_c))  ∧&#10;                           v2 = getPossibleValuesOfPonCapability(c2↦p)∧&#10;                           condition(c1↦p_c↦v_c)=TRUE ∧ getPossibleValuesOfPonCapability(c2↦p_c)⊆ v_c ∧&#10;                           v2 ⊂ v_p ⇒ (p↦c2↦v2)↦(c1↦v1) ∈ specifies" org.eventb.core.theorem="true"/>
    <org.eventb.core.axiom name="_CQvBceGqEe-OnJfusbHiIA" org.eventb.core.comment="if v1 is a conditionalvalue and condition does not holds for c2 and  v2 &lt;: v_p then v2 specifies v1&#10;inference rule R4 when non conditionalValue specifies a conditionalValue */" org.eventb.core.generated="false" org.eventb.core.label="AXM_specifiesofConditionalValue3" org.eventb.core.predicate="∀c1,c2,p,p_c,v_c,v_p,v_p2,v1,v2· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid  ∧&#10;                                    p_c≠p ∧&#10;                                    {p,p_c}⊆ getPropertiesForCapability(c1)∩getPropertiesForCapability(c2)    ∧&#10;                                    v_c ⊆ hasMGV(p_c)  ∧&#10;                                    v_p ⊆hasMGV(p)∧ v_p2 ⊆hasMGV(p) ∧&#10;                                    v1 = getPossibleValuesOfPonCapability(c1↦p) ∧ v1=CND(c1↦p↦v_p↦v_p2↦condition(c1↦p_c↦v_c))  ∧&#10;                                    v2 = getPossibleValuesOfPonCapability(c2↦p) ∧&#10;                                    condition(c2↦p_c↦v_c)=FALSE  ∧&#10;                                    v2 ⊂ v_p2 ⇒ (p↦c2↦v2)↦(c1↦v1) ∈ specifies"/>
    <org.eventb.core.axiom name="_yqdQ4OcfEe-hz-Q-PeYf9Q" org.eventb.core.comment="A is variantOf B =&gt;getPropertiesForCapability(c2)⊆getPropertiesForCapability(c1)&#10;theorem @THM_variantOf_Asymmetric ∀ c1,c2,c3,r· c1 ∈ Capability_valid ∧&#10;c2 ∈ Capability_valid ∧ c3 ∈ Capability_valid ∧ r ∈ Capability_valid ↔ Capability_valid  ∧ c1↦c1∉ r ∧&#10;(c1↦c2 ∈r ∧ c2↦c3∈r ⇒c1↦c3∈r)⇒ (c1↦c2 ∈r ⇒c2↦c1∉r)" org.eventb.core.generated="false" org.eventb.core.label="AXM_variantOf_condition" org.eventb.core.predicate="∀c1,c2· c1 ∈ Capability_valid ∧ c2 ∈ Capability_valid ⇒(&#10;                             getPropertiesForCapability(c2)⊈getPropertiesForCapability(c1)⇒&#10;                                c1↦c2 ∉  variantOf )"/>
</org.eventb.core.contextFile>
